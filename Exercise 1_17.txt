Алгоритмы возведения в степень из этого раздела основаны на повторяющемся умножении. Подоб-
ным же образом можно производить умножение с помощью повторяющегося сложения. Следующая
процедура умножения (в которой предполагается, что наш язык способен только складывать, но
не умножать) аналогична процедуре expt:
(define (* a b)
(if (= b 0)
0
(+ a (* a (- b 1)))))
Этот алгоритм затрачивает количество шагов, линейно пропорциональное b. Предположим теперь,
что, наряду со сложением, у нас есть операции double, которая удваивает целое число, и halve,
которая делит (четное) число на 2. Используя их, напишите процедуру, аналогичную fast-expt,
которая затрачивает логарифмическое число шагов.

(define (even? a)
  (define (% a b)
    (if (< a b) a (% (- a b) b)))
  (if (= (% a 2) 0) #t #f))
(define (double x)
  (* x 2))
(define (halve x)
  (/ x 2))
(define (fast-multi a b)
  (cond ((= b 0) 0)
        ((even? b) (double (fast-multi a (halve b))))
        (else (+ a (fast-multi a (- b 1))))))
